from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import tempfile
import shutil
from sentence_transformers import SentenceTransformer
import chromadb
import google.generativeai as genai
import json
from document_processor import extract_text_from_pdf, extract_text_from_docx, process_document_text

app = Flask(__name__)
CORS(app)
UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

GEMINI_API_KEY = "AIzaSyAWKs1pgZMAPSE0807otH5AK2WzmmQMT14"
genai.configure(api_key=GEMINI_API_KEY)
gemini_model = genai.GenerativeModel('gemini-2.0-flash')

embedding_model = SentenceTransformer('all-MiniLM-L6-v2')

chroma_client = chromadb.PersistentClient(path="./rag_db")
collection_name = "my_contract_collection"
try:
    contract_collection = chroma_client.get_collection(name=collection_name)
    print(f"Loaded existing ChromaDB collection: {collection_name}")
except:
    contract_collection = chroma_client.create_collection(name=collection_name)
    print(f"Created new ChromaDB collection: {collection_name}")

def chunk_text(text, chunk_size=500, overlap=50):
    chunks = []
    words = text.split()
    i = 0
    while i < len(words):
        chunk = " ".join(words[i:i + chunk_size])
        chunks.append(chunk)
        i += chunk_size - overlap
        if i < 0:
            i = 0
    return chunks

@app.route('/upload_document', methods=['POST'])
def upload_document():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if file:
        filepath = os.path.join(UPLOAD_FOLDER, file.filename)
        file.save(filepath)

        try:
            document_text = process_document_text(filepath)

            analysis_text_limit = 4000
            limited_document_text = document_text[:analysis_text_limit]

            analysis_prompt = f"""
            You are an AI legal assistant. Analyze the following contract and respond **only in valid JSON** format using this structure:

            {{
              "summary": "...",
              "balance_score": 0-100,
              "key_clauses": [
                {{
                  "type": "...",
                  "content": "...",
                  "analysis": "...",
                  "issues": ["...", "..."]
                }}
              ],
              "overall_assessment": "..."
            }}

            Do not include any explanations outside the JSON.

            Contract text:
            {limited_document_text}
            """

            analysis_response = gemini_model.generate_content(
                analysis_prompt,
                generation_config=genai.types.GenerationConfig(
                    response_mime_type="application/json",
                    response_schema={
                        "type": "OBJECT",
                        "properties": {
                            "summary": {"type": "STRING"},
                            "balance_score": {"type": "NUMBER"},
                            "key_clauses": {
                                "type": "ARRAY",
                                "items": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "type": {"type": "STRING"},
                                        "content": {"type": "STRING"},
                                        "analysis": {"type": "STRING"},
                                        "issues": {"type": "ARRAY", "items": {"type": "STRING"}}
                                    },
                                    "required": ["type", "content", "analysis"]
                                }
                            },
                            "overall_assessment": {"type": "STRING"}
                        },
                        "required": ["summary", "balance_score", "key_clauses", "overall_assessment"]
                    }
                )
            )

            analysis_result = {}
            if analysis_response.candidates and len(analysis_response.candidates) > 0 and \
               analysis_response.candidates[0].content and analysis_response.candidates[0].content.parts and \
               len(analysis_response.candidates[0].content.parts) > 0:
                json_string = analysis_response.candidates[0].content.parts[0].text

                try:
                    analysis_result = json.loads(json_string)
                    print("Initial contract analysis successfully generated by Gemini.")
                except json.JSONDecodeError as e:
                    print(f"Error decoding JSON from Gemini for initial analysis: {e}. Raw string: '{json_string}'")
                    analysis_result = {
                        "summary": "Initial analysis could not be generated due to invalid JSON from AI.",
                        "balance_score": 50,
                        "key_clauses": [],
                        "overall_assessment": f"AI returned malformed JSON: {e}"
                    }
            else:
                block_reason = analysis_response.prompt_feedback.block_reason.name if analysis_response.prompt_feedback else "Unknown"
                print(f"Gemini API blocked initial analysis response. Reason: {block_reason}")
                analysis_result = {
                    "summary": "Initial analysis could not be generated.",
                    "balance_score": 50,
                    "key_clauses": [],
                    "overall_assessment": f"AI analysis was blocked or empty. Reason: {block_reason}"
                }

            chunks = chunk_text(document_text)

            chunk_embeddings = embedding_model.encode(chunks).tolist()

            ids = [f"doc_{os.path.basename(filepath)}_chunk_{i}" for i in range(len(chunks))]
            metadatas = [{"source": os.path.basename(filepath), "chunk_index": i} for i in range(len(chunks))]

            existing_ids = contract_collection.get(where={"source": os.path.basename(filepath)}, include=[])['ids']
            if existing_ids:
                contract_collection.delete(ids=existing_ids)
                print(f"Deleted {len(existing_ids)} existing chunks for {os.path.basename(filepath)}")

            contract_collection.add(
                documents=chunks,
                embeddings=chunk_embeddings,
                metadatas=metadatas,
                ids=ids
            )
            print(f"Successfully processed and embedded {len(chunks)} chunks from {file.filename}")

            return jsonify({
                "message": "Document processed, analyzed, and indexed successfully!",
                "chunks_indexed": len(chunks),
                "analysis": analysis_result
            }), 200

        except Exception as e:
            print(f"Error processing document: {e}")
            return jsonify({"error": f"Failed to process document: {str(e)}"}), 500
        finally:
            if os.path.exists(filepath):
                os.remove(filepath)

@app.route('/ask_question', methods=['POST'])
def ask_question():
    data = request.json
    question = data.get('question')

    if not question:
        return jsonify({"error": "No question provided"}), 400

    try:
        question_embedding = embedding_model.encode(question).tolist()

        results = contract_collection.query(
            query_embeddings=[question_embedding],
            n_results=3,
            include=['documents', 'distances']
        )

        retrieved_chunks = results['documents'][0] if results['documents'] else []

        if not retrieved_chunks:
            return jsonify({
                "answer": "I cannot find a related answer in the indexed documents.",
                "explanation": "No relevant text chunks were retrieved from the database."
            }), 200

        context_for_llm = "\n---\n".join(retrieved_chunks)

        prompt_template = f'''
        You are an AI legal assistant. Your task is to answer the user's question by extracting information *strictly and only* from the "Contract text" provided.

        **Instructions for Answering:**
        1.  **Direct Extraction:** Find the most direct and concise answer to the "Question" within the "Contract text".
        2.  **No External Knowledge:** Do NOT use any information not present in the "Contract text".
        3.  **"Not Found" Condition:** If the answer is genuinely NOT explicitly stated or directly inferable from the "Contract text", you MUST provide the exact phrase: "I cannot find a related answer in the provided contract text."
        4.  **Explanation:** If an answer is found, provide the *exact sentence(s) or phrase(s)* from the "Contract text" that directly supports your answer in the 'explanation' field. If the answer was "not found", set 'explanation' to 'N/A'.
        5.  **JSON Format ONLY:** Your entire response MUST be a valid JSON object. Do NOT include any other text, greetings, or markdown outside this JSON.

        **JSON Structure:**
        {{
        "answer": "Your extracted answer or 'I cannot find a related answer in the provided contract text.'",
        "explanation": "The direct quote from the contract text, or 'N/A'."
        }}

        ---
        Question:
        {question}

        ---
        Contract text:
        {context_for_llm}
        '''

        response = gemini_model.generate_content(
            prompt_template,
            generation_config=genai.types.GenerationConfig(
                response_mime_type="application/json",
                response_schema={
                    "type": "OBJECT",
                    "properties": {
                        "answer": {"type": "STRING"},
                        "explanation": {"type": "STRING"}
                    },
                    "required": ["answer", "explanation"]
                }
            )
        )

        if response.candidates and len(response.candidates) > 0 and \
           response.candidates[0].content and response.candidates[0].content.parts and \
           len(response.candidates[0].content.parts) > 0:

            json_string = response.candidates[0].content.parts[0].text
            parsed_json = json.loads(json_string)
            return jsonify(parsed_json), 200
        else:
            block_reason = response.prompt_feedback.block_reason.name if response.prompt_feedback else "Unknown"
            return jsonify({
                "error": f"Gemini API did not return valid content or was blocked. Reason: {block_reason}",
                "answer": "Unable to get a valid response from the AI. Please try again or rephrase.",
                "explanation": "AI response was empty or blocked."
            }), 500

    except Exception as e:
        print(f"Error during question answering: {e}")
        return jsonify({
            "error": f"An error occurred during question answering: {str(e)}",
            "answer": "An internal error occurred. Please check the backend logs.",
            "explanation": "Backend processing error."
        }), 500

if __name__ == '__main__':
    app.run(debug=True)